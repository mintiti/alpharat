//! Cross-language parity test: verify Rust FlatEncoder matches Python FlatObservationBuilder.
//!
//! Loads JSON fixtures generated by `scripts/generate_encoder_fixtures.py`, reconstructs the
//! game state from the fixture config, runs `FlatEncoder::encode_into()`, and compares against
//! the Python-generated expected output.
//!
//! Run: `cargo test -p alpharat-sampling --test parity`
//! Generate fixtures first: `uv run python scripts/generate_encoder_fixtures.py`

use alpharat_sampling::{FlatEncoder, ObservationEncoder};
use pyrat::game::types::MudMap;
use pyrat::{Coordinates, Direction, GameBuilder, GameState};
use serde::Deserialize;
use std::collections::HashMap;

const TOLERANCE: f32 = 1e-6;

#[derive(Deserialize)]
struct Fixture {
    name: String,
    width: u8,
    height: u8,
    max_turns: u16,
    walls: Vec<WallDef>,
    mud: Vec<MudDef>,
    cheese: Vec<PosDef>,
    p1_pos: PosDef,
    p2_pos: PosDef,
    #[serde(default)]
    moves: Vec<[u8; 2]>,
    expected: Vec<f32>,
}

#[derive(Deserialize)]
struct PosDef {
    x: u8,
    y: u8,
}

#[derive(Deserialize)]
struct WallDef {
    pos1: PosDef,
    pos2: PosDef,
}

#[derive(Deserialize)]
struct MudDef {
    pos1: PosDef,
    pos2: PosDef,
    value: u8,
}

fn load_fixture(name: &str) -> Fixture {
    let path = format!(
        "{}/tests/fixtures/{}.json",
        env!("CARGO_MANIFEST_DIR"),
        name
    );
    let data = std::fs::read_to_string(&path)
        .unwrap_or_else(|e| panic!("Failed to read fixture {path}: {e}"));
    serde_json::from_str(&data).unwrap_or_else(|e| panic!("Failed to parse fixture {path}: {e}"))
}

fn build_game(f: &Fixture) -> GameState {
    // Build walls (bidirectional)
    let mut walls: HashMap<Coordinates, Vec<Coordinates>> = HashMap::new();
    for w in &f.walls {
        let p1 = Coordinates::new(w.pos1.x, w.pos1.y);
        let p2 = Coordinates::new(w.pos2.x, w.pos2.y);
        walls.entry(p1).or_default().push(p2);
        walls.entry(p2).or_default().push(p1);
    }

    // Build mud
    let mut mud = MudMap::new();
    for m in &f.mud {
        let p1 = Coordinates::new(m.pos1.x, m.pos1.y);
        let p2 = Coordinates::new(m.pos2.x, m.pos2.y);
        mud.insert(p1, p2, m.value);
    }

    // Build cheese positions
    let cheese: Vec<Coordinates> = f.cheese.iter().map(|c| Coordinates::new(c.x, c.y)).collect();

    let p1 = Coordinates::new(f.p1_pos.x, f.p1_pos.y);
    let p2 = Coordinates::new(f.p2_pos.x, f.p2_pos.y);

    let mut game = GameBuilder::new(f.width, f.height)
        .with_custom_maze(walls, mud)
        .with_custom_positions(p1, p2)
        .with_custom_cheese(cheese)
        .with_max_turns(f.max_turns)
        .build()
        .create(None)
        .unwrap();

    // Replay moves
    for [p1_dir, p2_dir] in &f.moves {
        let d1 = Direction::try_from(*p1_dir).expect("invalid p1 direction");
        let d2 = Direction::try_from(*p2_dir).expect("invalid p2 direction");
        game.make_move(d1, d2);
    }

    game
}

fn run_parity_check(name: &str) {
    let fixture = load_fixture(name);
    let game = build_game(&fixture);
    let encoder = FlatEncoder::new(fixture.width, fixture.height);

    assert_eq!(
        encoder.obs_dim(),
        fixture.expected.len(),
        "[{name}] obs_dim mismatch: encoder={} vs fixture={}",
        encoder.obs_dim(),
        fixture.expected.len()
    );

    let mut buf = vec![0.0f32; encoder.obs_dim()];
    encoder.encode_into(&game, &mut buf, 0);

    let mut mismatches = Vec::new();
    for (i, (got, want)) in buf.iter().zip(fixture.expected.iter()).enumerate() {
        if (got - want).abs() > TOLERANCE {
            mismatches.push((i, *got, *want));
        }
    }

    assert!(
        mismatches.is_empty(),
        "[{}] {} mismatches (tolerance={}):\n{}",
        fixture.name,
        mismatches.len(),
        TOLERANCE,
        mismatches
            .iter()
            .take(20)
            .map(|(i, got, want)| format!("  [{i}] got={got} want={want}"))
            .collect::<Vec<_>>()
            .join("\n")
    );
}

#[test]
fn parity_open_5x5() {
    run_parity_check("open_5x5");
}

#[test]
fn parity_wall_5x5() {
    run_parity_check("wall_5x5");
}

#[test]
fn parity_mud_5x5() {
    run_parity_check("mud_5x5");
}

#[test]
fn parity_midgame_5x5() {
    run_parity_check("midgame_5x5");
}

#[test]
fn parity_mud_stuck_5x5() {
    run_parity_check("mud_stuck_5x5");
}

#[test]
fn parity_asymmetric_scores_5x5() {
    run_parity_check("asymmetric_scores_5x5");
}

#[test]
fn parity_nonsquare_7x5() {
    run_parity_check("nonsquare_7x5");
}
